## Exceptions & errors handling in Unity

An exception is a problem that arises during the execution of a program. \
An exception is a response to an exceptional circumstance that arises while a program is running.



### C# handle exceptions & errors


C# exception handling is built upon four keywords: **try**, **catch**, **finally**, and **throw**.

-   **try** − A try block identifies a block of code for which particular exceptions is activated. It is followed by one or more catch blocks.
    
-   **catch** − A program catches an exception with an exception handler at the place in a program where you want to handle the problem. The catch keyword indicates the catching of an exception.
    
-   **finally** − The finally block is used to execute a given set of statements, whether an exception is thrown or not thrown. For example, if you open a file, it must be closed whether an exception is raised or not.
    
-   **throw** − A program throws an exception when a problem shows up. This is done using a throw keyword.
    

```cs
try {
   // statements causing exception
} catch( ExceptionName e1 ) {
   // error handling code
} catch( ExceptionName e2 ) {
   // error handling code
} catch( ExceptionName eN ) {
   // error handling code
} finally {
   // statements to be executed
}
```

C# **exceptions are represented by classes**. The **exception classes** in C# are **mainly directly or indirectly derived** from the **`System.Exception`** class.  
Some of the **exception classes** derived from the **`System.Exception`** class are the **`System.ApplicationException`** and **`System.SystemException`** classes.

The **`System.ApplicationException`** class supports exceptions generated by application programs. Hence the exceptions defined by the programmers should derive from this class.

The **`System.SystemException`** class is the **base class** for all **predefined system exception**.

-   **`System.IO.IOException`** : Handles I/O errors.
-   **`System.IndexOutOfRangeException`** : Handles errors generated when a method refers to an array index out of range.
-   **`System.ArrayTypeMismatchException`** : Handles errors generated when type is mismatched with the array type.
-   **`System.NullReferenceException`** : Handles errors generated from referencing a null object.
-   **`System.DivideByZeroException`** : Handles errors generated from dividing a dividend with zero.
-   **`System.InvalidCastException`** : Handles errors generated during typecasting.
-   **`System.OutOfMemoryException`** : Handles errors generated from insufficient free memory.
-   **`System.StackOverflowException`** : Handl



### Unity `Debug` class
You can also use UnityEngine **`Debug`** class to handle exceptions, errors, warning etc..

-   **`Debug.LogError`**: Use Debug.LogError to log error messages to the Unity Console.
-   **`Debug.LogWarning`**: A variant of Debug.Log that logs a warning message to the console.
-   **`Debug.LogException`**: A variant of Debug.Log that logs an error message from an exception to the console.
-   **`Debug.Assert`** : Use Debug.Assert to check conditions that should always be true. If the condition is false, Unity will log an error in the Console.


### Examples

```cs
try
        {
            // Do something that can throw an exception
        }
        catch (Exception e)
        {
            Debug.LogException(e, this);
        }
```

#### 1. **Using `try-catch` Blocks**

-   You can use `try-catch` blocks to handle exceptions in specific parts of your code where errors might occur.
-   Wrap potentially risky code in a `try` block, and handle the exception in the `catch` block.
  
  ```cs
        try
        {
            // Code that might throw an exception
            int result = 10 / int.Parse("0");
        }
        catch (System.Exception ex)
        {
            Debug.LogError("An error occurred: " + ex.Message);
        }
    ```

#### 2. Error Logging with `Debug.LogError`

Use `Debug.LogError` to log error messages to the Unity Console. This will help you identify where an error occurred without crashing the game.

```cs

if (playerHealth <= 0)
{
    Debug.LogError("Player health is zero or below!");
}

```


#### 3. Assertions with `Debug.Assert`

Use **`Debug.Assert`** to check conditions that should always be true. \
If the condition is false, Unity will log an error in the Console.

```cs
Debug.Assert(player != null, "Player object is not assigned!");

```

#### 4. Unity's Debugging Tools

-   **Debug.LogError**: Use this to log errors in the Console with a stack trace.
-   **Debug.LogWarning**: Logs non-critical issues or potential problems.
-   **Debug.Log**: For general messages to track execution.

#### 5. Unity’s `Application.logMessageReceived`
Capture all log messages, including errors, and handle them globally:

```cs

void OnEnable() {
    Application.logMessageReceived += HandleLog;
}

void HandleLog(string logString, string stackTrace, LogType type) {
    if (type == LogType.Error || type == LogType.Exception)
        Debug.LogError("Global Error: " + logString);
}

```

### `throw Exception` vs `Debug.LogError`

**Summary**: 

-   **`throw Exception`**: For handling critical, unrecoverable errors where program execution **must halt**.
-   **`Debug.LogError`**: For diagnosing issues without breaking program execution, ideal for debugging during development.
-   For debugging purposes, prefer `Debug.LogError`. For actual error handling in robust programs, use `throw Exception`.


**Key Differences**

| Feature | `throw Exception` | `Debug.LogError` |
| --- | --- | --- |
| **Purpose** | Signal and handle critical errors | Log errors for debugging only |
| **Execution Impact** | Halts program unless caught | Does not halt program |
| **Error Handling** | Supports `try-catch` for recovery | No built-in recovery mechanism |
| **Visibility** | Visible in the Unity Console (if unhandled) | Visible in the Unity Console |
| **Stack Trace** | Includes detailed stack trace automatically | Provides less detailed context |
| **Use in Production** | Intended for critical errors | Useful during development |

#### **For Debugging:**

-   Use `Debug.LogError` if you want to **log a problem but not interrupt program execution**. This is especially helpful during development to investigate issues without breaking the flow of the game.
    
    Example:
    
    ```cs
        if (playerHealth < 0)
        {
            Debug.LogError("Player health is below zero!");
        }
    ```

#### **For Error Handling:**

-   Use `throw Exception` if the error is **critical** and requires **immediate attention or corrective action**.
    
    Example:
    
    ```cs
        if (playerData == null)
        {
            throw new NullReferenceException("Player data is missing!");
        }
    ```

#### **Combination:**

Sometimes, you might combine the two approaches:

-   Use `Debug.LogError` to log non-critical issues or warnings.
-   Use `throw Exception` for issues that require halting execution.

#### **General Advice**

-   **During Development:**
    -   Use `Debug.LogError` for identifying issues without disrupting testing.
    -   Use `Debug.LogWarning` for less severe problems.
-   **In Production:**
    -   Minimize or remove `Debug.LogError` calls to avoid cluttering logs.
    -   Use exceptions (`throw`) sparingly for recoverable issues or critical failures that require program intervention.

### ref 
https://docs.unity3d.com/ScriptReference/Debug.html \
https://learn.microsoft.com/en-us/dotnet/api/system.exception?view=net-8.0

C# Exception.cs: \
https://github.com/dotnet/runtime/blob/5535e31a712343a63f5d7d796cd874e563e5ac14/src/libraries/System.Private.CoreLib/src/System/Exception.cs
